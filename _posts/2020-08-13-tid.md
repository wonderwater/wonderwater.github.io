---
layout: post
title: "分布式事务"
date: 2020-08-13 19:00
categories: "6.824"
tags:
    - distribution
    - database
---




主题：分布式事务=并发控制+原子提交

难点：
多数据记录，多服务器的分片，多client

client应用常常涉及多写和多读
- 银行转账
- 投票
- 连接社交关系
我们想对应用端隐藏实现细节和失败
这是传统数据库关注的，今天的材料是数据库相关，但其中的想法也能用于很多分布式系统

传统得方案：事务，程序员标记一组代码的起点和终点，作为事务

案例：
```text
  x、y是银行余额——数据库表的记录
  x、y在不同服务器上
  x、y值开始都是$10
  T1 and T2 are transactions
    T1: transfer $1 from x to y
    T2: audit, to check that no money is lost
  T1:             T2:
  begin_xaction   begin_xaction
    add(x, 1)       tmp1 = get(x)
    add(y, -1)      tmp2 = get(y)
  end_xaction       print tmp1, tmp2
                  end_xaction
```

什么是事务的正确性行为？
ACID
- Atomic -- all writes or none, despite failures
    > 要么都做完，要么都没做
- Consistent -- obeys application-specific invariants
    > 始终遵循应用指定的不变性
- Isolated -- no interference between xactions -- serializable
    > xactions之间不互相干扰，可串行化
- Durable -- committed writes are permanent
    > 提交后的写数据是永久的

我么也关心分布式事务的ACID的特性：多服务器的数据分片

可串行化指什么？
你可以执行一些并发的事务，得到相同的结果（两方面：输出、数据库的状态）
结果是可串行化的描述：
存在一组事务串行执行的顺序，结果和真正执行时一致。

你可以检查执行结果是否是可串行化的：
找一组顺序能得到相同结果。比如我们的案例中，可能的串行顺序是
```text
T1; T2
T2; T1
```
所以正确的结果是：
```text
T1; T2 : x=11 y=9 "11,9"
T2; T1 : x=11 y=9 "10,10"
```
虽然结果不太一样，但都是对的，除此以外，其他结果都不对。两事务的实现可能是并行的，但要保证想串行的顺序一样的执行。

为什么可串行化是流行的？
- 编程的简单模型，不被并发问题困扰，可以写出复杂的事务；
- 允许事务对不同记录并行执行

如果发生问题，事务可以abort终止
- 终止是一个对记录un-does的操作
- 事务可能自发的终止：比如账户不存在，或y的余额不够
- 系统也可能触发终止：比如解决死锁
- 服务器挂掉，导致事务终止
- 应用可能要在重新发起事务

分布式事务两大块：
- 并发控制（提高独立性、可串行化）
- 原子提交（提供原子性）

## 并发控制：维持并发事务的正确性

两类并发控制：
- 悲观的

用之前锁上记录，冲突时造成锁等待
- 乐观的

使用记录是不锁
提交的时候，再检查读、写是否是可串行化的
冲突时，引发终止和重试
称为Optimistic Concurrency Control (OCC)

悲观的策略在冲突频繁是效率更高，乐观的策略在冲突少时效率更高

今天主要讨论悲观的策略

两阶段锁（Two-phase locking）是一种可串行化的实现方式

定义：
- 事务在使用记录时要获取记录锁
- 事务要一直持有锁，直到事务提交或终止以后

我们的例子，2PL：
假设T1、T2同时启动，事务系统自动获取记录所需的锁，所以T1、T2中有个事务先拿到x的记录锁，
另一个事务要等待它执行完成，这就阻止了非可串行化的发生


细节：
每个数据库记录都有把锁，分布式的情况，
锁一般存在记录的服务器上
[diagram: clients, servers, records, locks]

一个执行中的事务在第一次使用，需要时请求锁
add()、get()导致隐式的记录锁请求；
end_xaction()释放所有锁。

所有的锁都是独占的（我们的讨论里，不考虑读写锁的）

全称是“强约束两段锁”（strong strict two-phase locking）

相比线程锁（比如Go的Mutex），更加方便：
- 需要显示begin/end_xaction
- DB自动的在第一次使用记录时上锁
- DB自动在事务结束时解锁
- DB自动在发生死锁是终止事务

为什么要持有锁直到commit/abort完成？
为什么不用完记录就释放锁？

用我们的案例：

假设T2在get(x)以后就释放x的锁
T1就可以在T2的两个get之间执行，所以T2的结果是10,9

这不是可线性化的执行，既不是 `T1;T2`，也不是`T2;T1`

另一种情况：

假设T1写完x，然后释放x的锁，T2读取x并输出，T1终止，
那么T2实际用了个不存在的值了。我们本应该也终止T2，级联终止（cascading abort）

2PL产生死锁，比如
```text
  T1      T2
  get(x)  get(y)
  get(y)  get(x)
```
系统要检测（环？锁超时？），并终止事务。

2PL会禁止正确的（可串行化结果）执行吗？
yes，比如：
```text
  yes; example:
    T1        T2
    get(x)  
              get(x)
              put(x,2)
    put(x,1) 
```
这种顺序会被禁止，但是结果x=1，也是可串行化的（T2;T1）

Q: 描述一种情况，2PL的效率比简单锁的效率更高。
简单锁：只要使用记录，就锁住包括这些记录在内的及其他的全部记录，终止/提交后释放锁

## 下个主题：分布式事务和失败
分布式事务如何处理失败？
假设，我们的例子里，x和y在不同worker服务器上，
- 计算x服务器+1，但y再-1前挂了？
- x的服务器+1，y发现账户不存在了？
- x、y都执行完成，但不能确定对方是否完成？

我们需要原子性提交

一组计算机协作完成一些任务
每台计算机有不同的角色
确定原子性：所有都执行，或都不执行
难点：失败、性能

协议：两阶段提交（two-phase commit），
用于分布式数据库的多服务器事务

配置：
数据在多个服务器上分片，事务运行于事务协作（transaction coordinators，TCs）
对于每个读或写，TC发生RPC给关联的分片服务器
- 每个服务器都是参与者（participant）
- 每个参与者管理自己分片上的数据的锁

在很多并发事务的情况，有多个TCs，TC授予每个事务唯一的事务ID（TID）
每条消息，每个表项都记录TID，为了避免混乱

不失败情况下的两阶段提交
[time diagram: TC, A, B]
- TC发送put(),get()等RPC给A，B
- TC收到事务结束
- TC发送PREPARE消息给A、B
- 如果A可以提交，回复YES，处于prepared状态，B也类似
- 如果A、B都回复YES，TC发送COMMIT给A、B
- 如果任何一方回复NO，TC发送ABORT给A、B
- A、B收到COMMIT消息后提交，回复ACK

正确性？
A、B都不能commit，直到两方都同意

要是B故障重启？
如果B发送YES后挂了，B必须记得（即使挂了），
因为A可能已经收到COMMIT并执行提交了，
所以B重启后也必须提交

因此参与者必须持久化的状态：
- B在回复YES前，要持久化修改的数据
- 如果B重启，磁盘存YES但未提交，B要询问TC或等待TC重发
- 同时B要继续维护事务的锁
- 如果TC回复COMMIT，B才能提交

要是TC故障重启？
如果TC重启前已经发送COMMIT，TC必须要记得，因为worker可能已经提交了，
因此TC必须在发送前将COMMIT持久化，故障重启后要重发COMMIT，或者参与者查询。
参与者要过滤重复的COMMITs（通过TID）

要是TC没有得到B的回复（YES\NO）
- 可能B挂了，或者网络超时
- TC超时，终止事务
- Good：允许所有服务器释放锁

要是B在等待PREPARE时，超时或者挂了？
此时B还没回复PREPARE，所以TC还没决定是否提交，
所以B自己挂了，可以释放锁，有PREPARE时，回复NO

要是B回复YES后，没有收到COMMIT或ABORT？
B能否自己abort？不行！因为TC可能已经收到全部的YES，并已经发COMMIT给A了，但发给B前挂了
所以A已经提交了，B终止则不正确！
当然B也不能自己提交，因为A可能回复了NO。

所以B回复了YES，要等待TC的决定。

关键点：
提交或终止的决定来自单实体——TC，
这简化了两阶段提交，关键在于A、B回复YES，必须等待TC的结果。

TC何时能忘记已经提交的事务？
如果收到所有的ACK，即不会有参与者再来询问的事务

参与者何时能忘记已经提交的事务？
在回复ACK以后。
如果又收到COMMIT，记录里没有这个事务了，说明肯定已经提交和删除了，再回复ACK即可。

两阶段提交分析
用于分片的数据库，涉及多分片的事务。
但声誉并不好：
- slow：多轮消息
- slow：磁盘写入
- 一直持有锁，阻塞其他xactions
- TC挂了会造成无限阻塞（并且锁不释放）

因此一般用于简单的小领域，比如非银行间的，非航司间的，非跨地区的。

更快的分布式事务设计是热门方向。

Raft和两阶段提交解决的是不同的问题，
Raft通过副本得到高可用性，比如允许一些服务器挂掉。这些服务器做的是一样的事。

2PC的参与者做不同的事，虽然都参与2PC，但并不提供高可用，因为所有的服务器都要在线。

Raft则不用保证所有，只要大多数在线即可

要是我们既想要高可用和原则性提交呢？
[diagram]

- TC和其他服务器都通过Raft进行复制
- 运行2PC在这些副本服务
- 那么就能允许一些失败，仍然可以运行
- Lab4就在做这样的事

下一节，Spanner使用这种结构













































