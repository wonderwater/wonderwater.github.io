---
layout: post
title:  "java基础知识（二）"
date: 2020-06-30 21:00
tags:
    - java
---


## hashmap in java 8

### resize - initialize

```java
newCap = DEFAULT_INITIAL_CAPACITY; // 16
threshold = DEFAULT_INITIAL_CAPACITY * DEFAULT_INITIAL_CAPACITY; // (16*75%)
Node<K,V>[] table = (Node<K,V>[])new Node[newCap];
```

初始化的代码，HashMap主要存储结构：Node数组，Node用于表示key-value
数组的长度一定是2^n次方，有以下几个优点
1. 这对通过后续的hash值，求数组索引有效率的提升（否则一般需要用耗时的求余操作）
2. 配合resize技巧
数组的每一项Node，一般是链表结构；但在一定条件下会转换成红黑树结构，那么此时的Node对象实际是TreeNode：
1. table.length至少大于MIN_TREEIFY_CAPACITY（64）
2. 如果长度达到TREEIFY_THRESHOLD（8）
有转成红黑树，也有转会链表的情况：链表长度小于UNTREEIFY_THRESHOLD（6）


### hash

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
一个新的Node对象，要加入到table中，首先要确定加入数组的哪一项，然后在确定插入该项的链表或树

### put

1. 通过key的哈希结果值hash，table下标i=`(table.length - 1) & hash`
2. 如果table[i] == null, 直接生成Node放入
3. 如果table[i]是TreeNode实例，红黑树插入操作
4. 否则就是链表结构，遍历链表，插入或更新Node，并检查是否需要转换为红黑树
5. 最后，如果当前存储的Node数超过阈值threshold，则resize

#### 红黑树插入操作[code][1]
table[i]是rb-tree的root，rb-tree是平衡二叉树结构，进行搜索时，通过和当前节点比较，判断向左或向右遍历
1. 通过hash值比较
2. key的类实现了Comparable，进行比较
3. 通过System.identityHashCode，计算出key的值，进行比较



#### 转换为红黑树

1. 先将链表转成双向链表
2. 初始化红黑树，然后将每个节点取出，加入红黑树，平衡红黑树
3. 最后将红黑树的root节点，调整到双向链表头部（简单的链表操作，把root移除，然后插入头部），写回table[i]
这里的红黑树实现和《算法导论》是一致的，再平衡的大概过程：
首先插入节点x是红色的，位于叶子节点，这时不影响黑高度，但是xp也可能是红色的，就违反了规则，我们讨论xp==xpp.left的情况，另一个情况类似。
这时候有主要的三种情况需要处理：
1. x的叔节点是红色的，也就是xpp的节点都是红的，那么把xpp的子节点置黑，xpp置红，这时候，我们的焦点就是xpp，把xpp当做x，继续判断
2. x的叔节点是黑色的，并且x==xp.right，那么left_rotate(xp)，然后我们关注的焦点就是xp，把xp当做x，继续判断
3. x的叔节点是黑色的，并且x==xp.left，那么right_rotate(xpp)，xpp置红，然后我们关注的焦点就是xp，把xp当做x，继续判断
以上三种情况，最后x都是红的，那么当xp为黑时，或者x就是root（需要置黑），就可以结束了



### get


## ConcurrentHashMap in java 8

### cas优化
1. 给table[i]赋值时
2. 扩容sizeCtl，当然需要double check
3. 统计线程count和basecount
4. 红黑树的访问，LOCKSTATE

LOCKSTATE的状态转换，在可能写操作红黑树是，需要申请写标志：`lockRoot()`

```java

        /**
         * Acquires write lock for tree restructuring.
         */
        private final void lockRoot() {
            if (!U.compareAndSwapInt(this, LOCKSTATE, 0, WRITER))
                contendedLock(); // offload to separate method
        }

        /**
         * Possibly blocks awaiting root lock.
         */
        private final void contendedLock() {
            boolean waiting = false;
            for (int s;;) {
                if (((s = lockState) & ~WAITER) == 0) {
                    if (U.compareAndSwapInt(this, LOCKSTATE, s, WRITER)) {
                        if (waiting)
                            waiter = null;
                        return;
                    }
                }
                else if ((s & WAITER) == 0) {
                    if (U.compareAndSwapInt(this, LOCKSTATE, s, s | WAITER)) {
                        waiting = true;
                        waiter = Thread.currentThread();
                    }
                }
                else if (waiting)
                    LockSupport.park(this);
            }
        }

```
1. 首先没有读/写在进行，那么尝试置位写标志，成功后，并清除自己设置的等待
2. 要是读/写在进行，且无线程等待，尝试置位等待标志，成功后，设置waiting线程设为自己
3. 以上的情况都不满足，且自身已经设置等待，就park住

读操作：
```java
final Node<K,V> find(int h, Object k) {
    if (k != null) {
        for (Node<K,V> e = first; e != null; ) {
            int s; K ek;
            if (((s = lockState) & (WAITER|WRITER)) != 0) {
                if (e.hash == h &&
                    ((ek = e.key) == k || (ek != null && k.equals(ek))))
                    return e;
                e = e.next;
            }
            else if (U.compareAndSwapInt(this, LOCKSTATE, s, s + READER)) {
                TreeNode<K,V> r, p;
                try {
                    p = ((r = root) == null ? null :
                         r.findTreeNode(h, k, null));
                } finally {
                    Thread w;
                    if (U.getAndAddInt(this, LOCKSTATE, -READER) ==
                        (READER|WAITER) && (w = waiter) != null)
                        LockSupport.unpark(w);
                }
                return p;
            }
        }
    }
    return null;
}
```
在有写/等待操作的前提下，通过双线链表的方式遍历，
否则尝试设置读标记，成功后进行树的查找，最后，当最后一个读操作退出时，unpark等待的线程

> 注意s是本地变量，不存在并发风险。


## 学习和总结

1. 并发：使用本地变量，避免共享变量

[1]: java.util.HashMap.TreeNode.putTreeVal
